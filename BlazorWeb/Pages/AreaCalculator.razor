@page "/AreaCalculator"
@inject IJSRuntime JS
<PageTitle>Polygon Area Calculator</PageTitle>

<h1>
        <span id="tr" class="lang-dependant">Poligon Alan Hesabı </span>
        <span id="en" class="lang-dependant">Polygon Area Calculator</span>
    </h1>
    <p>
        <span id="tr" class="lang-dependant">Bu sayfayı Google maps üzerinden bir parselin alanını hesaplamak için
            kullanabilirsiniz.
            Harita üzerinde bir noktaya sağ tıkladığınızda açılan menünün en üstünde koordinatlar görünür. koordinatlar
            üzerine mouse ile tıklandığında kopyalanmış olurlar.
        </span>
        <span id="en" class="lang-dependant">This page may be used to calculate area of a parcel by using google maps.
            You may copy coordinates of a point on the map by right click and then click on the coordinates shown on top
            of the menu.
        </span>
    </p>
    <h2>
        <span id="tr" class="lang-dependant">Girdiler</span>
        <span id="en" class="lang-dependant">Inputs</span>
    </h2>
    <p>
        <span id="tr" class="lang-dependant">Koordinatlar virgülle ayrılmış olmalıdır (x, y)</span>
        <span id="en" class="lang-dependant">Coordinates should be seperated by comma (x, y)</span>
    </p>

    <input id="GeoLoc-Deg" name="GeoLoc-Deg" type="checkbox">
    <label for="GeoLoc-Deg">
        <span id="tr" class="lang-dependant">Derece, Global Konumlandırma sistemi koordinatları olarak al(enlem, boylam)</span>
        <span id="en" class="lang-dependant">Degree, accept GPS coordinates (latitude, longitude)</span>
    </label>

    <div id="coordinates-input-field">

        <ol id="coordinates" class="input-list">
            <li class="coords-input-item">
                <input type="text" class="coord-input" onchange="updateScene()">
            </li>
            <li class="coords-input-item">
                <input type="text" class="coord-input" onchange="updateScene()">
            </li>
            <li class="coords-input-item">
                <input type="text" class="coord-input" onchange="updateScene()">
            </li>
        </ol>
        <div id="coordinates-control-field">
            <BUTTON onclick="addNewFieldToCoords()" class="adder-setter">+</BUTTON>
            <BUTTON onclick="removeNewFieldToCoords()" class="adder-setter">-</BUTTON>
        </div>
        <div id="submitter" onclick="calculateArea()">
            <span id="tr" class="lang-dependant">Sonuç al </span>
            <span id="en" class="lang-dependant">Get result</span>
        </div>
        <svg id="geometryScreen" height="300" width="500">
        </svg>
    </div>

    <h2>
        <span id="tr" class="lang-dependant">Sonuç</span>
        <span id="en" class="lang-dependant">Result</span>
    </h2>

    <div>
        <div id="result-warning">
            <span id="tr" class="lang-dependant">Girdilerinizi kontrol ediniz. Koordinatlar ", " ile ayrılmış
                olmalı</span>
            <span id="en" class="lang-dependant">Check your inputs. The coordinates should be divided by ", "</span>
        </div>
        <textarea id="result-field"></textarea>
    </div>
    <script>
        const svgns = "http://www.w3.org/2000/svg";
        let coords = [];
        const isCoordsGeological = () => {
            let checkbox = document.getElementById("GeoLoc-Deg");
            return checkbox.checked;
        };
        let coordsBoundary = {
            x_max: null,
            x_min: null,
            y_max: null,
            y_min: null,
            x_trans: null,
            y_trans: null,
            scale: null,
        };

        const GeoLocationalConstants = {
            R: 6.3781e6,
            R_latitude: (latitude, unit) => {
                let R = GeoLocationalConstants.R;
                if (unit == "deg") return R * Math.cos(Math.PI * latitude / 180);
                if (unit == "rad") return R * Math.cos(latitude);
            },
        };

        //longitude is Y axis
        const distanceOnLongitude = (y, from = 0, unit = "deg") => {
            let R = GeoLocationalConstants.R;
            if (unit == "deg") {
                return R * Math.PI * (y - from) / 180;
            }
            if (unit == "rad") {
                return R * (y - from);
            }
        }

        //latitude is X axis
        const distanceOnLatitude = (b, latitude, from = 0, unit = "deg") => {
            let R = GeoLocationalConstants.R_latitude(latitude, unit = unit);
            if (unit == "deg") {
                return R * Math.PI * (b - from) / 180;
            }
            if (unit == "rad") {
                return R * (b - from);
            }
        }

        const updateScene = () => {
            coordsBoundary = {
                x_max: null,
                x_min: null,
                y_max: null,
                y_min: null,
                x_trans: null,
                y_trans: null,
                scale: null,
            };
            console.log("scene updated");
            setCoordinates();
            drawPolygon();

        }
        const addNewFieldToCoords = () => {
            let listNode = document.getElementById("coordinates");
            let element = document.createElement("li");
            element.setAttribute("class", "coords-input-item");
            element.setAttribute("onchange", "updateScene()");
            element.innerHTML = "<input type=\"text\" class=\"coord-input\">";
            listNode.appendChild(element);
        }
        const removeNewFieldToCoords = () => {
            let listNode = document.getElementById("coordinates");
            if (listNode.children.length > 3) {
                listNode.removeChild(listNode.lastChild);
            }
        }
        const calculateArea = () => {
            hideWarningNode();
            if (coords.length < 3) {
                showWarningNode();
                return;
            };

            let area = 0;
            updateScene();
            //let2s calculate area
            for (let i = 0; i < coords.length - 1; i++) {
                let x = coords[i][0];
                let y = coords[i][1];
                let x_next = coords[i + 1][0];
                let y_next = coords[i + 1][1];
                area += (x_next * y - x * y_next) / 2;
            }
            area = Math.abs(area);
            console.log("area : " + area);
            showResult(area);
            drawPolygon();

        }
        const setCoordinates = () => {
            coords = [];
            let childs = document.querySelectorAll(".coord-input");
            let invalid = false;

            for (child of childs) {
                let coordinate = parseCoordinateInput(child.value);

                if (coordinate[0] == null) {
                    console.log("invalid input");
                    invalid = true;
                    if (coords.length > 2) showWarningNode();
                    break;
                }
                coords.push(coordinate);

                if (coordsBoundary.x_max < coordinate[0] || coordsBoundary.x_max == null) {
                    coordsBoundary.x_max = coordinate[0];
                }
                if (coordsBoundary.x_min > coordinate[0] || coordsBoundary.x_min == null) {
                    coordsBoundary.x_min = coordinate[0];
                }
                if (coordsBoundary.y_max < coordinate[1] || coordsBoundary.y_max == null) {
                    coordsBoundary.y_max = coordinate[1];
                }
                if (coordsBoundary.y_min > coordinate[1] || coordsBoundary.y_min == null) {
                    coordsBoundary.y_min = coordinate[1];
                }
            };

            if (invalid) return null;

            //we shall close the polygone
            coords.push(coords[0]);
        };

        const getGeometricScale = (svgWidth, svgHeight) => {
            let dx_max = coordsBoundary.x_max - coordsBoundary.x_min;
            let dy_max = coordsBoundary.y_max - coordsBoundary.y_min;
            let maxDiff = Math.max(dx_max, dy_max);
            let refDim = Math.min(svgWidth, svgHeight);
            let scale = refDim / maxDiff;
            console.log(scale);
            coordsBoundary.x_trans = (svgWidth / 2) - scale * (coordsBoundary.x_max + coordsBoundary.x_min) / 2;
            coordsBoundary.y_trans = (svgHeight / 2) - scale * (coordsBoundary.y_max + coordsBoundary.y_min) / 2;
            coordsBoundary.scale = scale;
            return scale;
        };

        const parseCoordinateInput = (inputString) => {
            let x;
            let y;
            let value = inputString.trim();
            let dividedValues = value.split(',');
            let isGeologicalCoords = isCoordsGeological();

            if (dividedValues.length == 2) {
                x = Number(dividedValues[0].trim());
                y = Number(dividedValues[1].trim());
            }
            else {
                return [null, null];
            }

            if(isGeologicalCoords){
                //Geologic coordinates are fliped (latitude, longitude) = (x, y)
                //so we will make (x_geo, y_geo) = (longitude, latitude)
                // because x_geo is distence from zero longitude(greenwich) and y_geo is distance from equator
                x_geo = distanceOnLatitude(y, x);
                //invers of y coords due to screen axis
                y_geo = distanceOnLongitude(x);
                return [x_geo, y_geo];
            }
            return [x, y];
        };

        const drawPolygon = () => {
            if (coords.length < 3) return;
            let svgCanvas = document.getElementById("geometryScreen");
            let polygon = document.createElementNS(svgns, "polygon");
            let canvasHeight = Number(svgCanvas.getAttribute("height"));
            let canvasWidth = Number(svgCanvas.getAttribute("width"));

            svgCanvas.innerHTML = "";
            polygon.setAttribute("points", generatePointsAttr(canvasWidth, canvasHeight));
            polygon.setAttribute("style", "fill:lime;stroke:purple;stroke-width:1");
            svgCanvas.appendChild(polygon);
        };

        const generatePointsAttr = (canvasWidth, canvasHeight) => {
            let points = "";
            let scale = getGeometricScale(canvasWidth, canvasHeight);
            let x;
            let y;

            for (let coord of coords) {
                x = coordsBoundary.x_trans + scale * coord[0];
                y = coordsBoundary.y_trans + scale * coord[1];
                y = canvasHeight - y;
                points += x + ',' + y + " ";
            } 
            return points;           
        };

        const showResult = (res) => {
            let isGeologicalCoords = isCoordsGeological();

            if(isGeologicalCoords) res = res.toFixed(3)  + " m" + '\u00B2';

            document.getElementById("result-field").value = "" + res;
        };
        const showWarningNode = () => {
            document.getElementById("result-warning").style.display = "block";
        };
        const hideWarningNode = () => {
            document.getElementById("result-warning").style.display = "none";
        };
    </script>
@code {
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;
        await Task.Delay(200);
        await JS.InvokeVoidAsync("checkLang"); // Calls the JS function
    }
}